---
title: "ndd-perturb-ipsc"
author: "Daniel Brock"
date: "2025-08-27"
output: html_document

### Forked Repo
# Edit by Yifan Chen
# 12-13-2025
---

# 0. Importing Libraries and Setting the File Path to 10X output

```{r setup, include=FALSE}
# Importing libraries  
library(tidyverse)
library(readxl)
library(writexl)
library(qs2)
library(Seurat)
library(Mixscale)
library(DropletUtils)
library(SingleCellExperiment)
library(gprofiler2)
library(presto)
library(pheatmap)
library(rstatix)
library(plyr)
library(gtools)
library(cowplot)
library(patchwork)
library(progress)

# Setting the file path to the 10X files
dir_10x <- "/home/rdhin/data/perturbed-compass-10x/COM-iP-none-aggr/"



```

# 1. Importing 10X files

## 1.1 iPSCs

```{r}
# Importing 10X output (unzipped folder containing barcodes/features/matrix) - 
mats <- Read10X(data.dir = paste0(dir_10x, "count/reads")) # loading file is much slower on RStudio Server due to IO speed limit
print(names(mats))
```

```{r}
# Building the seurat object with gene expression and CRISPR guide capture as a secondary assay
so <- CreateSeuratObject(counts = mats[["Gene Expression"]], assay = "RNA")
so[["CRISPR"]] <- CreateAssayObject(counts = mats[["CRISPR Guide Capture"]])
DefaultAssay(so) <- "RNA"
```

```{r}
# Optional export to seurat object - with NO processing
qs_save(object = so, file = paste0(getwd(), "/data/0_COMPASS-iPSC-no-processing.qs2"))
```

```{r}
# Reading in the processed seurat objects
so <- qs_read(file = paste0(getwd(), "/data/0_COMPASS-iPSC-no-processing.qs2"))
meta <- so@meta.data
```

# 2. gRNA calls from CellRanger - Gaussian distribution

## 2.1 Plotting number of gRNAs per cell

```{r}
# Unzip the crispr_analysis.tar.gz into crispr_reads folder
grna.calls <- read.csv(file = paste0(dir_10x, "count/crispr_reads/protospacer_calls_per_cell.csv"), row.names = 1)

```

```{r}
### gRNA per cell graphs

# Histogram of gRNA calls
num.grna.calls <- table(grna.calls$num_features) %>% as.data.frame()
num.grna.calls$Var1 <- as.numeric(num.grna.calls$Var1)

# >5 gRNA calls
num.5.grna.calls <- num.grna.calls[num.grna.calls$Var1 >= 5, ] %>% colSums()
num.5.grna.calls$Var1 <- ">5"
num.5.grna.calls <- data.frame("Var1" = num.5.grna.calls$Var1, "Freq" = num.5.grna.calls$Freq)

# 0 gRNA calls
num.0.grna.calls <- data.frame("Var1" = 0, "Freq" = ncol(so) - nrow(grna.calls))

# Merging
num.grna.calls <- num.grna.calls[num.grna.calls < 5, ] %>% na.omit()
num.grna.calls <- rbind(num.grna.calls, num.5.grna.calls)
num.grna.calls <- rbind(num.grna.calls, num.0.grna.calls)
num.grna.calls$Var1 <- factor(num.grna.calls$Var1, levels = c("0", "1", "2", "3", "4", ">5"))

# Plotting
num.grna.hist <- num.grna.calls %>% ggplot(aes(x = Var1, y = Freq)) + 
  geom_bar(stat = "identity") + 
  geom_text(aes(label = Freq), vjust = -0.5) + 
  scale_y_continuous(expand = c(0, 0)) +
  expand_limits(y = max(num.grna.calls$Freq) * 1.1) +
  labs(x = "number of gRNAs per cell", y = "number of cells", title = "Number of gRNA Assignments per Cell: iPSCs") + 
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))
print(num.grna.hist)

# Saving plot
ggsave(plot = num.grna.hist, filename = "iPSC_figures_fork/guide_counts_histogram.png", width = 3000, height = 2000, units = "px", dpi = 300)
```

## 2.2 Filtering for cells that got 1 gRNA and adding gRNA metadata

```{r}
# Filtering for cells that only got 1 gRNA and adding metadata for gRNAs
grna.calls.filt <- grna.calls[grna.calls$num_features == 1, ]
grna.calls.filt <- grna.calls.filt %>% dplyr::select(feature_call, num_umis) %>% rownames_to_column(var = "sequence") 

# Inport the inital manifest of gRNA names
grna.names <- read.csv(file = paste0(dir_10x, "count/crispr_reads/feature_reference.csv")) %>%  dplyr::select("id", "name", "target_gene_name")

# Replace the name of gRNA with manifest
grna.calls.rename <- left_join(grna.calls.filt, grna.names, by = c("feature_call" = "id"))
grna.calls.rename <- grna.calls.rename %>% 
  select(sequence, num_umis, gRNA = name, target_gene_name)

!any(is.na(grna.calls.rename$gRNA)) # check if all guide has a name, pass if return "TRUE"

# Merging with gene & cleaned gRNA information
grna.calls.rename <- column_to_rownames(grna.calls.rename, var = "sequence")

# Making a column for non-targeting controls
grna.calls.rename$NT_gRNA <- ifelse(test = grepl("NTC", grna.calls.rename$gRNA), yes = "non-targeting", no = grna.calls.rename$gRNA)
```

```{r}
# Subsetting the seurat object for cells with 1 gRNA
so <- subset(so, cells = rownames(grna.calls.rename))

# Adding mitochondrial counts metadata
so[["percent.mt"]] <- PercentageFeatureSet(so, pattern = "^MT-")

# Adding metadata for gRNAs to the seurat object
so <- AddMetaData(so, metadata = grna.calls.rename)

# Extracting the metadata
meta <- so@meta.data
```

# 3. QC metrics

## 3.1 Visualizing violin plots

```{r}
# nFeatures
p1_qlow <- quantile(x = so$nFeature_RNA, 0.05)
p1_qhigh <- quantile(x = so$nFeature_RNA, 0.95)
p1 <- VlnPlot(object = so, 
              features = c("nFeature_RNA"),
              pt.size = 0, 
              cols = c("#037bfc", "#037bfc", "#037bfc")) +
  NoLegend() +
  geom_hline(yintercept = c(p1_qlow, p1_qhigh), linetype = "dashed", color = "red") +
  theme(axis.text.x = element_blank(), 
        axis.ticks.x = element_blank())+
  xlab(NULL)

# nCounts
p2 <- VlnPlot(object = so, 
              features = c("nCount_RNA"),
              pt.size = 0, 
              cols = c("#037bfc", "#037bfc", "#037bfc")) +
  NoLegend()+
    theme(axis.text.x = element_blank(), 
        axis.ticks.x = element_blank())+
  xlab(NULL)

# percent mitochondrial RNA
p3 <- VlnPlot(object = so, 
              features = c("percent.mt"),
              pt.size = 0, 
              cols = c("#037bfc", "#037bfc", "#037bfc")) +
  NoLegend() +
  geom_hline(yintercept = 10, linetype = "dashed", color = "red")+
  theme(axis.text.x = element_blank(), 
        axis.ticks.x = element_blank())+
  xlab(NULL)


# 3 plots
qc_filtering_plot <- p1 | p2 | p3
print(qc_filtering_plot)

# 2 filtering plots
qc_filtering_plot <- p1 | p3
print(qc_filtering_plot)

# Saving the plot
ggsave(plot = qc_filtering_plot, filename = "iPSC_figures_fork/QC_metrics_after_filtering.png", width = 2200, height = 1500, units = "px", dpi = 300)
```

## 3.2 FeatureScatter QC plots

```{r}
# FeatureScatter is typically used to visualize feature-feature relationships, but can be used for anything calculated by the object, i.e. columns in object metadata, PC scores etc.
plot1 <- FeatureScatter(so, feature1 = "nFeature_RNA", feature2 = "percent.mt") +NoLegend()
plot2 <- FeatureScatter(so, feature1 = "nCount_RNA", feature2 = "nFeature_RNA") +NoLegend()
qc_scatter <- plot1 + plot2
print(qc_scatter)

# Saving the plot
ggsave(plot = qc_scatter, filename = "iPSC_figures_fork/qc_scatter_after_filtering.png", width = 3500, height = 1500, units = "px", dpi = 300)
```

## 3.3 Filtering on QC metrics

```{r}
#### Apply filter matrix here - using 5% percentage mt as cutoff
n_before <- ncol(so)
so <- subset(so, subset = nFeature_RNA > p1_qlow & nFeature_RNA < p1_qhigh & percent.mt < 10)

# Count cells after
n_after <- ncol(so)
# Calculate percentage lost
percent_lost <- round((n_before - n_after) / n_before * 100, 2)

print(paste("You are removing", percent_lost, "% of your cells."))
```

# 4. Normalizing, Finding Variable Features, and Scaling

```{r}
# Normalizing
so <- NormalizeData(so, normalization.method = "LogNormalize", scale.factor = 10000)

# Finding Variable Features
so <- FindVariableFeatures(so, selection.method = "vst", nfeatures = 2000)

# Scaling
all.genes <- rownames(so)
so <- ScaleData(so, features = all.genes)
gc()
```

# 5. PCA and UMAP

## 5.1 PCA

```{r}
# PCA
so <- RunPCA(so)
```

```{r}
# Visualizations of PCA
elbow <- ElbowPlot(so)
print(elbow)

#DimHeatmap(so, dims = 1:15, cells = 500, balanced = TRUE)

# Saving the plot 
ggsave(plot = elbow, filename = "iPSC_figures_fork/PCA_elbow_plot.png", height = 2000, width = 3000, units = "px", dpi = 300)
```

```{r}
# PCA Plot
pca.plot <- DimPlot(so, reduction = "pca") + NoLegend()
print(pca.plot)

# Saving the plot 
#ggsave(plot = pca.plot, filename = "iPSC_figures/all_PCA_plot.png", height = 2000, width = 2000, units = "px", dpi = 300)
```

## 5.2 UMAP

```{r}
# Clustering the cells with UMAP
so <- FindNeighbors(so, dims = 1:15)  #15 PCs from elbowplot
so <- FindClusters(so, resolution = 1, algorithm = 4, verbose = FALSE)  #resolution optimal from 0.4-1.2. algorithm = Leiden (4), 1 = Louvain
head(Idents(so), 5)  #clusters can be found using the Idents() function

# UMAP
so <- RunUMAP(so, dims = 1:15)

```

```{r}
# Plotting a UMAP Plot
UMAP_plot <- FeaturePlot(so, 
                         reduction = "umap", 
                         features = c("NEUROG2", "RBFOX3", "MAP2", "POU5F1", "SOX2", "NANOG"), 
                         ncol = 3,
                         order = TRUE)


print(UMAP_plot)
ggsave(plot = UMAP_plot, filename = "iPSC_figures_fork/UMAP_plot_neuro-markers.png", width = 3000, height = 2000, dpi = 300, units = "px")

UMAP_by_gene <- DimPlot(so, reduction = "umap", group.by = "target_gene_name")
# Saving the plot
ggsave(plot = UMAP_by_gene, filename = "iPSC_figures_fork/UMAP_plot_by_gene.png", width = 3000, height = 2000, dpi = 300, units = "px")
```



## 5.3 ICA Reduction and tSNE plot

```{r}
so <- RunICA(so, features = VariableFeatures(so), nics = 50)
so <- RunTSNE(so, reduction = "ica", dims = 1:30)
tSNE <- DimPlot(so, reduction = "tsne", group.by = "target_gene_name") + ggtitle("t-SNE (Computed on ICA)")
ggsave(plot = tSNE, filename = "iPSC_figures_fork/tSNE_plot_by_gene.png", width = 3000, height = 2000, dpi = 300, units = "px")

```


```{r}
# Saving the processed seurat object
qs_save(object = so, file = paste0(getwd(), "/data/1_COMPASS-iPSC-gRNA-QC.qs2"))
```

```{r}
so <- qs_read(file = paste0(getwd(), "/data/1_COMPASS-iPSC-gRNA-QC.qs2"))
```

# 6. Number of cells per gRNA to plot synthetic lethality

```{r}
# Creating a dataframe with all the metadata
meta <- so@meta.data %>% as.data.frame()
meta <- meta %>% rownames_to_column(var = "cell_barcode") %>% as.data.frame()

# Plotting individual gRNAs
indiv_gRNA_counts <- table(meta$gRNA) %>% as.data.frame()
colnames(indiv_gRNA_counts) <- c("gRNA", "cell_counts")
indiv_gRNA_counts <- indiv_gRNA_counts %>% tidyr::separate(col = gRNA, into = c("gene", "replicate"), sep = "-", remove = FALSE)

# Calculating the mean and SEM for cell counts per guide
sem <- function(x) {
  s <- (sd(x)) / (sqrt(length(x)))
  return(s)
}
indiv_gRNA_counts <- indiv_gRNA_counts %>% dplyr::group_by(gene) %>% 
  dplyr::mutate(
    mean_cell_counts = mean(cell_counts),
    sem_cell_counts = sem(cell_counts)
  )
indiv_gRNA_counts2 <- indiv_gRNA_counts %>% dplyr::select(gene, mean_cell_counts, sem_cell_counts) %>% distinct()
indiv_gRNA_counts2$NT <- ifelse(test = indiv_gRNA_counts2$gene == "non", yes = "NT", no = "")

# Exporting to excel 
#write_xlsx(x = indiv_gRNA_counts, path = "tables/cell_counts_per_gRNA.xlsx")
```

```{r}
# Plotting mean and SEM for gRNAs per gene
indiv_gRNA_plot <- indiv_gRNA_counts2 %>% ggplot(aes(x = reorder(gene, mean_cell_counts), y = mean_cell_counts, fill = NT)) + 
  geom_col() + 
  geom_errorbar(aes(ymin = mean_cell_counts - sem_cell_counts, ymax = mean_cell_counts + sem_cell_counts), width = 0.3) + 
  scale_y_continuous(expand = c(0, 0)) + 
  scale_fill_manual(values = c("grey", "red")) + 
  labs(x = "Targeted Gene", y = "Cell Counts", title = "Mean gRNA Assignment per Cell") + 
  theme_classic() + 
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "none")
print(indiv_gRNA_plot)

# Saving the plot
ggsave(plot = indiv_gRNA_plot, filename = "iPSC_figures_fork/gRNA_assignment_counts.png", width = 2000, height = 1500, dpi = 300, units = "px")
```

## 6.1 Plot cell counts of each guide per gene compared to NTC

```{r}
list_of_genes <- unique(indiv_gRNA_counts[indiv_gRNA_counts$gene != "NTC", ]$gene)

# group all NTC cells together
average_ntc_cell_counts <- mean(indiv_gRNA_counts[indiv_gRNA_counts$gene == "NTC", ]$cell_counts)
sem_ntc_cell_counts <- sem(indiv_gRNA_counts[indiv_gRNA_counts$gene == "NTC", ]$cell_counts)

# add a new line in the df
indiv_gRNA_counts <- indiv_gRNA_counts %>% ungroup() %>% 
  dplyr::add_row(gRNA = "NT", gene = "NT", replicate = "NTC",
                                                          cell_counts = average_ntc_cell_counts,
                                                          mean_cell_counts = average_ntc_cell_counts,
                                                          sem_cell_counts = sem_ntc_cell_counts)

correct_order <- c("NTC", paste0("g", 1:20))
gene_plot_list <- list()

for (gene_plot in list_of_genes) {
  
  plot <- indiv_gRNA_counts %>% dplyr::filter(gene == gene_plot | gene == "NT")
  plot$replicate <- factor(plot$replicate, levels = correct_order)
  gRNA_cell_plot <- ggplot(plot, aes(x = replicate, y=cell_counts)) +
    geom_col(aes(fill = replicate == "NTC")) +
    scale_fill_manual(values = c("FALSE" = "grey40", "TRUE" = "lightblue"), guide = "none") +
    geom_errorbar(
      # Only pass the NTC rows to this specific layer
      data = subset(plot, replicate == "NTC"), 
      aes(
        ymin = cell_counts - sem_cell_counts, 
        ymax = cell_counts + sem_cell_counts
      ),
      width = 0.2 
    )+
    scale_y_continuous(expand = c(0, 0)) + 
    labs(x = "Guide", y = "Cell Counts", title = paste0(gene_plot, " gRNA Assignment per Cell")) + 
    theme_classic() + 
    theme(plot.title = element_text(hjust = 0.5),
          axis.text.x = element_text(angle = 45, hjust = 1),
          legend.position = "none")
  
  
   gene_plot_list[[gene_plot]] <- gRNA_cell_plot
}

# save all figures in folder
dir.create("iPSC_figures_fork/gRNA_cell_counts", showWarnings = FALSE)

# Loop through each gene in the list
for (gene_name in names(gene_plot_list)) {
  
  # 1. Retrieve the plot object
  current_plot <- gene_plot_list[[gene_name]]
  
  # 2. Create a dynamic filename (e.g., "gRNA_Plots/KDM6A_counts.pdf")
  file_name <- paste0("iPSC_figures_fork/gRNA_cell_counts/", gene_name, "_gRNA_cell_counts.png")
  
  # 3. Save the plot
  # width and height are in inches by default
  ggsave(filename = file_name, plot = current_plot, width = 2000, height = 1500, dpi = 300, units = "px")
  
  print(paste("Saved:", file_name))
}


```


# 7. Perfrom pair-wise Spearman correlation among NTC guides to check off targeting of NT guides

```{r}
so_ntc <- subset(so, subset = NT_gRNA == "non-targeting")

list_of_NT_gRNA <- unique(so_ntc@meta.data$gRNA)
Idents(so_ntc) <- "gRNA"
# set the order correct
ntc_guides <- str_sort(unique(so_ntc@meta.data$gRNA), numeric = TRUE)

# calculate average gene expression of all cells receiving the same guide
avg_expression <- AverageExpression(so_ntc, assays = "RNA", slot = "data")$RNA

# find variable features, default 2000
so_ntc <- FindVariableFeatures(so_ntc, nfeatures = 2000)
genes_to_use <- VariableFeatures(so_ntc)
avg_expression_subset <- avg_expression[genes_to_use, ]

cor_mat <- cor(as.matrix(avg_expression_subset), method = "spearman")
cor_mat <- cor_mat[ntc_guides, ntc_guides] # set order of the matrix

# plot spearman correlation

ntc_spearman_cor <- pheatmap(
  cor_mat, 
  main = "Spearman Correlation of NT Guides",
  display_numbers = TRUE,
  color = colorRampPalette(c("blue", "white", "red"))(100),
  breaks = seq(0.8, 1, length.out = 101),
  cluster_rows = FALSE, 
  cluster_cols = FALSE
)

ggsave(filename = "iPSC_figures_fork/NTC_Spearman_Correlation.png", plot = ntc_spearman_cor, width = 2000, height = 1500, dpi = 300, units = "px")

```

## 7.1 Perfrom pair-wise DEG among NT guides

```{r}
### Compare one NT guide against the rest of NTC combined

# Create a container to store results
deg_counts <- data.frame(
  Comparison = character(),
  Total = numeric(),
  Genes = character(),
  stringsAsFactors = FALSE
)


for (id in ntc_guides) {
  message(paste("Processing:", id, "vs remaining NTCs..."))
  
  rest_of_ntcs <- setdiff(ntc_guides, id)
  
  try({
    markers <- FindMarkers(
      so_ntc,
      ident.1 = id,
      ident.2 = rest_of_ntcs,
      min.pct = 0.1,
      logfc.threshold = 0.25,
      test.use = "wilcox",
      verbose = FALSE
    )
    
    sig_markers <- markers[markers$p_val_adj < 0.05, ]
    
    num_degs <- nrow(sig_markers)
    gene_list_str <- paste(rownames(sig_markers), collapse = ", ")

    deg_counts <- rbind(deg_counts, data.frame(
      Comparison = id,
      Total = num_degs,
      Genes = gene_list_str
    ))
    
  }, silent = TRUE)
}

print(deg_counts)


#### Correlation matrix style of DEG, performing pair-wise DEGs
deg_matrix <- matrix(0, nrow = length(ntc_guides), ncol = length(ntc_guides))
rownames(deg_matrix) <- ntc_guides
colnames(deg_matrix) <- ntc_guides

for (i in ntc_guides) {
  for (j in ntc_guides) {
    
    if (i == j) {
      deg_matrix[i, j] <- 0
      next
    }
    

    message(paste("Comparing:", i, "vs", j))
    
    # Run FindMarkers with error handling
    try({
      markers <- FindMarkers(
        so_ntc,
        ident.1 = i,
        ident.2 = j,
        min.pct = 0.1,
        logfc.threshold = 0.25,
        test.use = "wilcox",
        verbose = FALSE
      )
      
      n_sig <- sum(markers$p_val_adj < 0.05)
      deg_matrix[i, j] <- n_sig
      
    }, silent = TRUE)
  }
}

# plot the matrix
heat_map <- pheatmap(
  deg_matrix,
  cluster_rows = FALSE,
  cluster_cols = FALSE,
  display_numbers = TRUE, # Show the actual count inside the square
  number_format = "%.0f", # No decimals
  color = colorRampPalette(c("white", "red"))(50),
  main = "Pairwise DEGs between NTC Guides"
)

ggsave(filename = "iPSC_figures_fork/NTC_DEG_heatmap.png", plot = heat_map, width = 2000, height = 1500, dpi = 300, units = "px")


# check the gene of interest
rest_of_ntcs <- setdiff(list_of_NT_gRNA, "NTC-g9")
markers <- FindMarkers(
        so_ntc,
        ident.1 = "NTC-g9",
        ident.2 = rest_of_ntcs,
        min.pct = 0.1,
        logfc.threshold = 0.25,
        test.use = "wilcox",
        verbose = FALSE)
```



# 8. DEG between each guide and NTC to drop off guide that doesn't perturb target gene expression by 30%

```{r}
# list_of_guides <- grep("^NTC", unique(so@meta.data$gRNA), value = TRUE, invert = TRUE)
# guide_kd_result <- list()
# 
# pb <- progress_bar$new(
#   format = "  Testing Guides [:bar] :percent | Elapsed: :elapsed | ETA: :eta",
#   total = length(list_of_guides),
#   clear = FALSE,
#   width = 100
# )
# 
# for (guide in list_of_guides) {
#   target_gene <- unique(so@meta.data$target_gene_name[so@meta.data$gRNA == guide])
#   so_sub <- subset(so, subset = NT_gRNA == "non-targeting" | gRNA == guide)
#   
#   n_cells <- sum(so_sub$gRNA == guide)
#   if (n_cells < 4) {
#       # Print the name of the failing guide
#       message(paste("\nSkipping:", guide, "- Too few cells ( Count =", n_cells, ")"))
#       
#       # Tick progress bar so it doesn't get stuck
#       if (!pb$finished) pb$tick()
#       next # Skip to next iteration immediately
#   }
#   
#   so_sub$comparison_group <- ifelse(so_sub$gRNA == guide, "Knockdown", "Control")
#   Idents(so_sub) <- "comparison_group"
#   deg <- FindMarkers(so_sub, 
#                        ident.1 = "Knockdown", 
#                        ident.2 = "Control", 
#                        features = target_gene, # only test the target gene
#                        test.use = "MAST", 
#                        logfc.threshold = 0,
#                        min.pct = 0,
#                        verbose = FALSE)
#   
#   deg$guide_name <- guide
#   deg$target_gene <- target_gene
#   deg$cell_count <- n_cells
#   guide_kd_result[[guide]] <- deg
#   
#   if (!pb$finished) {
#     pb$tick()
#   }
#   
# }
# 
# gRNA_knockdown_summary <- do.call(rbind, guide_kd_result)
# 
# # save the table
# write_xlsx(gRNA_knockdown_summary, path = "iPSC_figures_fork/gRNA_knockdown_summary.xlsx")
```

## 8.1 Extract cell expression using matrix data and perform fast wilcox.test only on the target gene expression, filter out guide with <20 cells

```{r}
# Perfrom the same calculation using matrix
expr_matrix <- GetAssayData(so, layer = "data") 
meta_data <- so@meta.data

control_cells <- rownames(meta_data)[meta_data$NT_gRNA == "non-targeting"]
n_control <- length(control_cells)

# Setup ETA Progress Bar
pb <- progress_bar$new(
  format = "  Running [:bar] :percent | ETA: :eta",
  total = length(list_of_guides),
  clear = FALSE,
  width = 60
)

# Initialize storage
guide_kd_result <- list()
list_of_guides <- grep("^NTC", unique(so@meta.data$gRNA), value = TRUE, invert = TRUE)


for (guide in list_of_guides) {

  target_gene <- unique(meta_data$target_gene_name[meta_data$gRNA == guide])

    kd_cells <- rownames(meta_data)[meta_data$gRNA == guide]
    n_kd_cells <- length(kd_cells)
    
    # skip testing if less than 20 cells
    if (n_kd_cells < 20) {
      # Print name of failing guide
      message(paste("\nSkipping:", guide, "- Too few cells ( Count =", n_kd_cells, ")"))
      if (!pb$finished) pb$tick()
      next
    }
        
    vec_kd_cells <- expr_matrix[target_gene, kd_cells]
    vec_control <- expr_matrix[target_gene, control_cells]
        
    p_val <- suppressWarnings(wilcox.test(vec_kd_cells, vec_control)$p.value)
  
    mean_kd_v5 <- (sum(expm1(vec_kd_cells)) + 1) / length(vec_kd_cells)
    mean_ctrl_v5 <- (sum(expm1(vec_control)) + 1) / length(vec_control)
    manual_logfc_v5 <- log2(mean_kd_v5) - log2(mean_ctrl_v5)
    
    # F. Store Result
    guide_kd_result[[guide]] <- data.frame(
      guide_name = guide,
      target_gene = target_gene,
      cell_count = n_kd_cells, # Store the count
      p_val = p_val,
      avg_log2FC = manual_logfc_v5
    )

  
  # Update Progress Bar
  if (!pb$finished) pb$tick()
}


gRNA_knockdown_summary_matrix <- do.call(rbind, guide_kd_result)

# Save file
write_xlsx(gRNA_knockdown_summary_matrix, path = "iPSC_figures_fork/gRNA_knockdown_summary.xlsx")

```


## 8.2 Subset the Seurat object with only guide pass logFC filter

```{r}
gRNA_knockdown_summary_matrix <- gRNA_knockdown_summary_matrix %>% 
  dplyr::filter(avg_log2FC < log2(0.7) & p_val < 0.05)

# check guide left for each gene
table(gRNA_knockdown_summary_matrix$target_gene)

# extract a list of working guides
logFC_filter_guide <- gRNA_knockdown_summary_matrix$guide_name

# Subset Seurat object to contain only logFC filter guide and NTC
so_logFC_filter <- subset(so, subset = NT_gRNA == "non-targeting" | gRNA %in% logFC_filter_guide)

# Redo UMAP and PCA from this reduced dataset 
so_logFC_filter <- FindVariableFeatures(so_logFC_filter, selection.method = "vst", nfeatures = 2000)
so_logFC_filter <- ScaleData(so_logFC_filter)
so_logFC_filter <- RunPCA(so_logFC_filter, verbose = FALSE)
elbow_so_logFC_filter <- ElbowPlot(so_logFC_filter)
print(elbow_so_logFC_filter)

so_logFC_filter <- RunUMAP(so_logFC_filter, dims = 1:15)
logFC_UMAP <- DimPlot(so_logFC_filter, reduction = "umap", group.by = "target_gene_name") + ggtitle("UMAP after guide-logFC filter")
ggsave(plot = logFC_UMAP, filename = "iPSC_figures_fork/UMAP_plot_by_gene_after_logFC_filter.png", width = 3000, height = 2000, dpi = 300, units = "px")



so_logFC_filter <- RunICA(so_logFC_filter, features = VariableFeatures(so_logFC_filter), nics = 50)
so_logFC_filter <- RunTSNE(so_logFC_filter, reduction = "ica", dims = 1:30)
tSNE <- DimPlot(so_logFC_filter, reduction = "tsne", group.by = "target_gene_name") + ggtitle("t-SNE after guide-logFC filter")

ggsave(plot = tSNE, filename = "iPSC_figures_fork/tSNE_plot_by_gene_after_logFC_filter.png", width = 3000, height = 2000, dpi = 300, units = "px")

```

```{r}
# Saving the logFC-filtered seurat object
qs_save(object = so_logFC_filter, file = paste0(getwd(), "/data/2_COMPASS-iPSC-gRNA-logFC-filtered.qs2"))
```


# 8. Mixscale per gRNA

```{r}
# The standardized mixscale scores will be saved in the metadata under the column "mixscale_score". 
# Note: if multiple biological context (ex: cell lines) exists, we can use the "split.by" argument to specify the corresponding metadata column
```

```{r}
# perturbation scores per gRNA
so <- CalcPerturbSig(
  object = so,
  assay = "RNA",
  slot = "data",
  gd.class = "NT_gRNA",  #gRNA
  nt.cell.class = "NonTargeting",
  reduction = "pca",
  ndims = 5,
  num.neighbors = 20,
  new.assay.name = "Perturb_by_gRNA",  #perturb scores by gRNA
  split.by = NULL  #to specify the metadata column if multiple biological context (like cell lines exist)
)
```

```{r}
# MixScale Scores per gRNA
so <- RunMixscale(
  object = so,
  assay = "Perturb_by_gRNA",
  slot = "scale.data",
  labels = "NT_gRNA",  #per gRNA
  nt.class.name = "NonTargeting",
  min.de.genes = 5,  #5
  logfc.threshold = 0.2,  #0.2
  de.assay = "RNA",
  max.de.genes = 100,
  new.class.name = "mixscale_score_by_gRNA",  #by gRNAs
  fine.mode = F,
  verbose = T,
  split.by = NULL
)
```

```{r}
# Visualizations for Mixscale scores per gene (visualizing all gRNAs)
so_temp <- subset(so, gene %in% c("NonTargeting", "KMT2A"))
meta_temp <- so_temp@meta.data
print(table(meta_temp$NT_gRNA))

# Ridgeplot
RidgePlot(
    so_temp,
    features = "mixscale_score_by_gRNA",
    group.by = "NT_gRNA") + NoLegend() + coord_cartesian(xlim = c(-8, 20))
```

```{r}
so_temp <- subset(so, gene %in% c("NonTargeting", "TRRAP"))
VlnPlot(so_temp, features = "TRRAP", group.by = "NT_gRNA", alpha = 0) + 
  geom_boxplot(width = 0.5) + 
  geom_jitter(width = 0.1, alpha = 0.3, size = 0.5)
```

# 9. Differential Expression Analysis per gRNA

```{r}
# Importing the merged degs list - does not need any processing
de_list <- qs_read(file = "iPSC_gRNA_DEGs/iPSC_DEGs.qs2")
```

```{r}
# Tidying each DEGs dataframe - run initially, just import the processed merged dataset after
gRNA_counts <- table(so$NT_gRNA)
de_list2 <- list()
for (grna in names(de_list)) {
  df <- de_list[[grna]]
  #df$p_adj <- p.adjust(p = df$p_weight, method = "fdr")
  df <- df %>% dplyr::mutate(
    regulation = dplyr::case_when(
      p_weight < 0.05 & log2FC > log2(1.3) ~ "up",   #30% increase for upregulated DEGs
      p_weight < 0.05 & log2FC < log2(0.7) ~ "down"   #30% decrease for downregulated DEGs
    )
  )
  df$regulation <- factor(x = df$regulation, levels = c("up", "down"))
  df$gRNA <- grna
  df$cell_count <- gRNA_counts[grna]
  rownames(df) <- NULL
  df <- df %>% tidyr::separate(col = "gRNA", into = c("target_gene", "guide_replicate"), sep = "-", remove = FALSE)
  de_list2[[grna]] <- df
}

# Optional export of merged DEGs list
#qs_save(object = de_list2, file = "iPSC_gRNA_DEGs/iPSC_DEGs_processed.qs2")

# Merging all gRNA DEGs into one dataframe
degs <- dplyr::bind_rows(de_list2)
```

```{r}
# Adding a target gene column and significance markers column
degs <- degs %>% dplyr::group_by(gRNA) %>% 
  dplyr::mutate(
    target = ifelse(gene_ID == target_gene, yes = "target", no = "non-target")
  )

degs_filt <- degs[degs$target=="target", ]
degs_filt <- rstatix::add_significance(degs_filt, p.col = "p_weight")
```

```{r}
# Number of DEGs per gRNA
degs_counts <- table(degs$gRNA, degs$regulation) %>% as.data.frame()
colnames(degs_counts) <- c("gRNA", "regulation", "Freq")
degs_counts <- degs_counts %>% tidyr::pivot_wider(names_from = "regulation", values_from = "Freq")

# Merging with degs_filt
degs_filt <- merge(degs_filt, degs_counts, on = "gRNA")
degs_filt$total_degs <- degs_filt$up + degs_filt$down
degs_filt <- degs_filt[, c("gRNA", "gene_ID", "target_gene", "guide_replicate", "target", "DE_method", "log2FC", "beta_weight", "p_weight", "p_weight.signif", "regulation", "up", "down", "total_degs", "cell_count")]

# Exporting to excel
#write_xlsx(x = degs_filt, path = "iPSC_gRNA_DEGs/iPSC_gRNA_DEGs_counts.xlsx")
```

```{r}
# Log2FC matrix for heatmap
degs_heat <- degs_filt %>% tidyr::pivot_wider(id_cols = target_gene, names_from = guide_replicate, values_from = log2FC)
degs_heat <- column_to_rownames(degs_heat, var = "target_gene")
degs_heat <- degs_heat[, paste0("g", c(1:36))]  #reordering column names
degs_heat <- as.matrix(degs_heat)
degs_heat[is.na(degs_heat)] <- 0
degs_heat <- degs_heat[, 1:20]  #optional cutoff for 20 gRNAs

# p values matrix for heatmap
degs_p <- degs_filt %>% tidyr::pivot_wider(id_cols = target_gene, names_from = guide_replicate, values_from = p_weight.signif)
degs_p <- column_to_rownames(degs_p, var = "target_gene")
degs_p <- degs_p[, paste0("g", c(1:36))]  #reordering column names
degs_p <- as.matrix(degs_p)
degs_p[is.na(degs_p)] <- ""
degs_p <- degs_p[, 1:20]  #optional cutoff for 20 gRNAs
```

```{r}
# Color scale: blue (neg) → white (0) → red (pos)
L <- max(abs(range(degs_heat, na.rm = TRUE)))         # symmetric limits
breaks <- seq(-L, L, length.out = 201)          # 200 intervals, includes 0
my_palette <- colorRampPalette(c("blue", "white", "red"))(200)

# (Optional) make sure the legend labels include 0 clearly
leg_breaks  <- c(-L, 0, L)
leg_labels  <- sprintf("%.2f", leg_breaks)

# Heatmap of log2FC knockdown efficiency
#pdf(file = "iPSC_figures/iPSC_gRNA_heatmap.pdf", width = 8, height = 19)
pheatmap(degs_heat,
         main = "iPSC gRNAs",
         color = my_palette,
         breaks = breaks,
         legend_breaks = leg_breaks,
         legend_labels = leg_labels,
         display_numbers = degs_p,  #TRUE or degs_p
         number_color = "black",
         fontsize_number = 8,
         cluster_cols = FALSE,
         cluster_rows = FALSE,
         angle_col = 0
         )
#dev.off()
```

# 10. Spearman correlation for each gRNA / gene to find off-target effects

```{r}
# Getting pseudo-bulk expression profiles per gRNA
so_small <- subset(so, gene %in% c("KMT2A"))  #, "non-targeting"
#so_small <- subset(so_small, !(NT_gRNA %in% c("KMT2B-16")))
Idents(so_small) <- "NT_gRNA"
pseudo_bulk_list <- AggregateExpression(so_small, return.seurat = FALSE, group.by = "NT_gRNA")
pseudo_bulk_counts <- pseudo_bulk_list$RNA

# log normalization
pseudo_bulk_norm <- log1p(t(t(pseudo_bulk_counts) / colSums(pseudo_bulk_counts)) * 10000)

# Identifying the top 2000 highly variable genes
hvg_genes <- VariableFeatures(so_small)
pseudo_bulk_subset <- pseudo_bulk_norm[hvg_genes, ]

# Spearman correlation
cor_mat <- cor(pseudo_bulk_subset, method = "spearman")
print(dim(cor_mat))
```

```{r}
# Color palette
col_palette <- colorRampPalette(c("navy", "white", "firebrick3"))(100)

# Plot the heatmap
#png(filename = "iPSC_figures/example_spearman.png", width = 2000, height = 2000, units = "px", res = 300)
pheatmap(cor_mat,
         color = col_palette,
         border_color = NA,        # Removes grid lines for a cleaner look
         clustering_distance_rows = "euclidean",
         clustering_distance_cols = "euclidean",
         clustering_method = "complete",
         main = "Spearman Correlation of gRNA Pseudo-bulk Profiles",
         fontsize_row = 8,         # Adjust font size based on number of gRNAs
         fontsize_col = 8,
         display_numbers = FALSE   # Set to TRUE if you want to see the correlation values
)
#dev.off()
```

# 11. Mixscale per gene after filtering out gRNAs that did not work

```{r}
# Getting the processed list of effective gRNAs
gRNA_effect <- read_xlsx(path = "iPSC_gRNA_DEGs/iPSC_gRNA_DEGs_counts.xlsx")
effective_gRNAs <- gRNA_effect %>% dplyr::filter(effective_gRNA == "yes") %>% dplyr::pull(gRNA)

# Filtering the seurat object for gRNAs that worked
so_filt <- subset(so, NT_gRNA %in% c(effective_gRNAs, "non-targeting"))
```

```{r}
# perturbation scores per gene (all effective gRNAs)
so_filt <- CalcPerturbSig(
  object = so_filt,
  assay = "RNA",
  slot = "data",
  gd.class = "gene",
  nt.cell.class = "non-targeting",
  reduction = "pca",
  ndims = 5,
  num.neighbors = 20,
  new.assay.name = "Perturb_by_gene",  
  split.by = NULL)

# MixScale Scores per gene (all effective gRNAs)
so_filt <- RunMixscale(
  object = so_filt,
  assay = "Perturb_by_gene",
  slot = "scale.data",
  labels = "gene",  #per gene
  nt.class.name = "non-targeting",
  min.de.genes = 5,
  logfc.threshold = 0.2,
  de.assay = "RNA",
  max.de.genes = 100,
  new.class.name = "mixscale_score_by_gene",  #by gRNAs
  fine.mode = F,
  verbose = T,
  split.by = NULL)
```

```{r}
# Visualizing Mixscale scores per gene
ridge <- RidgePlot(
    so_filt,
    features = "mixscale_score_by_gene",
    group.by = "gene") + NoLegend()
print(ridge)

# Saving the plot
#ggsave(plot = ridge, filename = "iPSC_figures/gene_ridge_plot.png", width = 2000, height = 2000, dpi = 300, units = "px")
```

```{r}
mixed_scatter <- Mixscale_ScatterPlot(object = so_filt, 
                     nt.class.name = "non-targeting", 
                     slct.ident = unique(so_filt$gene)[unique(so_filt$gene) != "non-targeting"][1:10], 
                     nbin = 10, 
                     facet_wrap = "gene") + NoLegend()
print(mixed_scatter)

# Saving the plot
#ggsave(plot = mixed_scatter, filename = "iPSC_figures/gene_mixscale_scatter.png", width = 2000, height = 2000, dpi = 300, units = "px")
```

# 12. hdWGCNA

```{r}
# Set up WGCNA
so_wgcna <- SetupForWGCNA(
  so_filt,
  gene_select = "fraction",  # the gene selection approach (genes that are expressed in a certain fraction of cells)
  fraction = 0.05,  # fraction of cells that a gene needs to be expressed in order to be included
  wgcna_name = "wgcna"
)
```

```{r}
# Construct metacells! 
so_wgcna <- MetacellsByGroups(
  seurat_obj = so_wgcna, 
  group.by = "gene",
  reduction = "pca",  #select the dimentionality reduction to perform KNN on
  k = 22,  #nearest-neighbors parameter (20-75 - smaller for smaller datasets)
  max_shared = 10,  #max number of shared cells between two metacells
  ident.group = "gene"  #set Idents to the metacell SO
  )  
```

```{r}
# Since we store the metacell expression information as its own SO, we can run seurat functions on the metacell data.  Here are some wrapper functions to do this.

# Getting the metacell object from the hdWGCNA experiment 
metacell_obj <- GetMetacellObject(so_wgcna)

# Applying the seurat workflow to the metacells and visualizing them with UMAP
so_wgcna <- NormalizeMetacells(so_wgcna)
so_wgcna <- FindVariableFeatures(so_wgcna, features=VariableFeatures(so_wgcna))
so_wgcna <- ScaleMetacells(so_wgcna, features=VariableFeatures(so_wgcna))
so_wgcna <- RunPCAMetacells(so_wgcna, features=VariableFeatures(so_wgcna), group.by.vars='gene')  #groupby?
ElbowPlot(so_wgcna)
so_wgcna <- RunUMAPMetacells(so_wgcna, reduction='pca', dims=1:40, min.dist = 0.1)

# Plotting UMAP of metacells
metacell_umap <- DimPlotMetacells(so_wgcna, group.by='gene') + umap_theme() + ggtitle("Target Gene")
metacell_umap

# Saving the plot
#ggsave(plot = metacell_umap, filename = "iPSC_figures/metacell_umap.png", width = 1700, height = 1500, dpi = 300, units = "px")
```
